---
tags:
  - 代码
---
## 最初

```Python
from openai import OpenAI
from pathlib import Path
import os

  
# 步骤1.实现一个简单的"关键词匹配"检索器
def retrieve(query):
    context = ""

    # 遍历所有文件 (假设所有文件都在 "Java" 目录下) 获取所有文件的路径[Path(Java/hello.md), Path("Java/1/world.md")]
    path_list = list(Path("Java").glob("**/*.md"))
    for path in path_list: # in 是子串匹配
        file_name = path.stem.split('.', 1)[-1]  # 分割后取"."后面的部分作为文件名
        if file_name in query: # path.stem返回的时路径的文件名，Path("Java/hello.md").stem 返回 "hello"
            # 如果找到匹配的文件，则读取文件内容
            print(f"Found matching file: {path}")
            context += path.read_text(encoding="utf-8") + "\n"
  
    return context
  

# 步骤2.增强Query
def augmented(query, context=""):
    if not context:
        return f"请简要回答下面问题：{query}"
    else:
        return f"""请根据上下文内容回答问题：{context}\n如果上下文信息不足以回答问题，请直接说:\"根据上下文信息无法回答，请提供更多信息\"\n问题是：{query}"""
        
        
# 步骤3.生成回答
def api(query):
    api_key = os.environ.get("DEEPSEEK_API_KEY")
  
    if not api_key:
        raise ValueError("DEEPSEEK_API_KEY environment variable is not set")

    client = OpenAI(api_key=api_key, base_url="https://api.deepseek.com")

    response = client.chat.completions.create(
        model="deepseek-chat",
        messages=[
            {"role": "system", "content": "You are a helpful assistant"},
            {"role": "user", "content": query},
        ],
        stream=False
    )
    return response.choices[0].message.content
  

if __name__ == "__main__":
    query = "Restful有哪些作用"
    context = retrieve(query)
    prompt = augmented(query, context)
    response = api(prompt)
    print(response)
```

目的：为了让大模型拥有特定领域的知识，以及实时的信息。

RAG的优势：
- 成本低，相对于微调，不需要训练。
- 可以随时更新知识库的内容。
- 可以限定领域的知识。
- 抑制幻觉，大模型回答根据现有资料。

目前基础方法的局限性：
- 通过关键词检索，当文档多的时候，不仅**时间复杂度大**，而且检索出来的庞大内容也容易消耗token。
- 当语义不完全匹配时，而是相似时，大模型回答的效果很差。（如文档中有无人机电池支持半小时的记录，但问续航多久时，难以回答）


